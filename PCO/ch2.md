# 信息存储与整数表示

## 知识点集锦

### 刘惠森

- 整数运算和浮点数运算的数学属性不同，这决定于它们处理数字表示有限性的方式不同——整数的表示精确；浮点数只是近似。

- 程序员应该力图使他们的程序在不同的机器和编译器上是可移植的。不同的机器通常指的是什么？cpu？操作系统？还是其它？
通常指的就是cpu和操作系统，书中2.1.4节中有关于这个内容的举例。

- 大多数Intel兼容机都采用小端法（little endian）这种规则来存储多字节数据。在编写网络应用程序和编写规避正常的类型系统的程序（系统级编程时使用强制类型转换）时会受到此规则的影响。

- 不同的机器类型使用不同的且不兼容的指令和编码方式。

- 整数的取反可以用整数和一个全1的二进制数进行异或来实现。

- C语言标准没有明确定义应该使用哪种类型的右移。对于无符号数据，右移必须是逻辑的。而对于有符号数据，算术的或者逻辑的右移都可以，这就意味这任何一种假设的右移形式的代码都潜在着可移植性问题。但是，实际上，几乎所有的编译器/机器组合都对有符号数据使用算术右移，且许多程序员也都假设机器会使用这种右移。

- C程序中的移位数量应该保持小于字长。java要求移位数量应该按照k mod w来计算。

- ISO C99标准在文件stdint.h中引入的intN_t和uintN_t类型可以确定整数类型的具体大小，可以获得更高的移植性。

- C语言无符号数和有符号数的转换原则时底层的位表示不变，应用相应的U2Tw或者U2Tw函数。

- 同时设计数据大小和符号的转换时，C语言标准要求先改变大小，之后再改变符号。


## 问题

无

# 信息存储与整数表示

## 知识点集锦

### 刘朝洋

- 大端法和小端法

最左边表示最高有效位(MSB)，最右边表示最低有效位(LSB)。

- 提高代码的可移植性

- 使用表达式`~0`生成一个全1的掩码，而不是采用0xFFFFFFFF，因为后者只适用于32位机器。

- 逻辑运算和位级运算的区别

逻辑运算符包括`&&`(AND)、`||`(OR)、`!`(NOT)，位级运算符包括`&`(AND)、`|`(OR)、`^`(EXCLUSIVE-OR)、`~`(NOT)。前者运算时是以整体的值来参与运算的，当整体值非0时，就将其看作1参与运算，否则就看作0；而后者是值的每一位参与运算。

另外，逻辑运算具有短路原则。

- 算术右移与逻辑右移

逻辑右移是向右移动k位，丢弃右端的k位，**左端用0填充**；算术右移是向右移动k位，丢弃右端的k位，**左端用最高位填充**。

- 类型长度

long长度为机器字长，long long为64位

- 强制类型转换

不会改变位模式，而会改变解释这些位的方式，即改变数值。比如v = -12345，unsigned v = 53191，这里-12345的补码表示与53191的16位无符号表示是完全一样的。

- 有符号数和无符号数

当执行一个运算时，如果它的一个云算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

## 问题

无
