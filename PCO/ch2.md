# 信息存储与整数表示

## 知识点集锦

### 刘惠森

- 整数运算和浮点数运算的数学属性不同，这决定于它们处理数字表示有限性的方式不同——整数的表示精确；浮点数只是近似。

- 程序员应该力图使他们的程序在不同的机器和编译器上是可移植的。不同的机器通常指的是什么？cpu？操作系统？还是其它？
通常指的就是cpu和操作系统，书中2.1.4节中有关于这个内容的举例。

- 大多数Intel兼容机都采用小端法（little endian）这种规则来存储多字节数据。在编写网络应用程序和编写规避正常的类型系统的程序（系统级编程时使用强制类型转换）时会受到此规则的影响。

- 不同的机器类型使用不同的且不兼容的指令和编码方式。

- 整数的取反可以用整数和一个全1的二进制数进行异或来实现。

- C语言标准没有明确定义应该使用哪种类型的右移。对于无符号数据，右移必须是逻辑的。而对于有符号数据，算术的或者逻辑的右移都可以，这就意味这任何一种假设的右移形式的代码都潜在着可移植性问题。但是，实际上，几乎所有的编译器/机器组合都对有符号数据使用算术右移，且许多程序员也都假设机器会使用这种右移。

- C程序中的移位数量应该保持小于字长。java要求移位数量应该按照k mod w来计算。

- ISO C99标准在文件stdint.h中引入的intN_t和uintN_t类型可以确定整数类型的具体大小，可以获得更高的移植性。

- C语言无符号数和有符号数的转换原则时底层的位表示不变，应用相应的U2Tw或者U2Tw函数。

- 同时设计数据大小和符号的转换时，C语言标准要求先改变大小，之后再改变符号。

### 刘朝洋

- 大端法和小端法

最左边表示最高有效位(MSB)，最右边表示最低有效位(LSB)。

- 提高代码的可移植性

使用表达式`~0`生成一个全1的掩码，而不是采用0xFFFFFFFF，因为后者只适用于32位机器。

- 逻辑运算和位级运算的区别

逻辑运算符包括`&&`(AND)、`||`(OR)、`!`(NOT)，位级运算符包括`&`(AND)、`|`(OR)、`^`(EXCLUSIVE-OR)、`~`(NOT)。前者运算时是以整体的值来参与运算的，当整体值非0时，就将其看作1参与运算，否则就看作0；而后者是值的每一位参与运算。

另外，逻辑运算具有短路原则。

- 算术右移与逻辑右移

逻辑右移是向右移动k位，丢弃右端的k位，**左端用0填充**；算术右移是向右移动k位，丢弃右端的k位，**左端用最高位填充**。

- 类型长度

long长度为机器字长，long long为64位

- 强制类型转换

不会改变位模式，而会改变解释这些位的方式，即改变数值。比如v = -12345，unsigned v = 53191，这里-12345的补码表示与53191的16位无符号表示是完全一样的。

- 有符号数和无符号数

当执行一个运算时，如果它的一个云算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

- 如何安全地比较两个无符号数

例1：写一个函数用来判定一个字符串是否比另一个更长。前提是必须使用字符串函数`strlen`，它的声明如下：

```
/* Prototype for library function strlen */
size_t strlen(const char *s);
```

假如我们的答案是这样的：

```
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
  return strlen(s) - strlen(t) > 0;
}
```

其实上面的函数存在问题，当s的长度小于t的长度时，该函数就会返回错误的结果。因为在头文件`stdio.h`中数据类型`size_t`是定义成`unsigned int`的，所以`strlen`返回结果是无符号的，它们的运算结果也作为无符号处理；而当结果为负数时，就会变成一个很大的无符号数，且大于0。

要想安全地比较，我们可以将上述代码改成：

```
return strlen(s) > strlen(t);
```

## 问题
###刘惠森
###刘朝洋

# 整数运算和浮点数
## 知识点集锦
### 刘惠森
- 在有符号数中，TMin=-TMin（由于有符号数的补码表示以及溢出处理规则决定）。因此，在函数的任何测试过程中，TMin都应该作为一种测试情况。

- 在C语言中，计算表达式（-x）和（~x+1）得到的结果完全一样。在调试中看到位级表示得数时可以用这种方法来计算数的值。

- 大多数机器的有符号和无符号加、乘法指令相同，这是因为无符号编码和补码的位级表示相同（阶段后的位级表示）。

### 刘朝洋

## 问题
### 刘惠森
- 整数运算溢出时的取模运算？

取模运算向负无穷大舍入。

- 浮点数的判等为什么要通过减法来实现，其底层的位级原理是什么？
### 刘朝洋
- 为什么模数加法会构成阿贝尔群？(P56)

首先，由于模数加法是可结合运算，而且每个元素存在逆元，因此模数加法所产生的元素可以构成一个群。同时，模数加法又是可交换的，因此它又可以构成一个阿贝尔群。

<<<<<<< HEAD
- 取模运算与取余运算的区别
=======
- 取模运算与取余运算的区别

# 整数运算和浮点数

- 无符号和补码的加法和乘法的位级表示相同，即下列C语言表达式始终为真：

```
x+y == ux+uy
x*y == ux*uy
```
>>>>>>> lcy
